---
layout: post
title: "Learning By Testing"
image: "assets/learning-by-testing.jpg"
image_alt: "Architecture sketch with a fine pen on top next to a ruler"
---
Learning how to write good tests has helped me tremendously demystify every codebase I was tasked to work with so far. As you tackle an unknown from both sides, what you think the world looks like now and also after something happened, you also learn to translate requirements into code, and vis versa.

Once you move past learning the syntax, a language finally becomes a powerful tool to wield. From here, a vast array of knowledge only waits to be discovered, like frameworks, paradigms and patterns. The most powerful method to expand your knowledge about a language and its ecosystem at this point is testing. Not only does a test provide you with guidance through the unknowns, it also teaches you to carefully map between requirement and code, and to truly understand the task you're trying to accomplish.

By now, I imagine you're familiar with my obsession for feedback loops. Whenever tasked with something where I find myself not knowing either requirements or the code-base, the question "How do I know if I'm going into the right direction" helps me find out where I need to dive in deeper, the requirement or the code. As my current roles involve coaching developers a lot, I found this question to be equally useful in mentoring situations where the mentees next learning angle is to move away from hacking to proper software engineering.

{% include responsive-image.html image="assets/learning-by-testing-test-annotated.png" image_alt="An annotated test in JavaScript" %}

As many others, I learned programming by playing around and hacking to just get the computer to do what I wanted to achieve. PHP, being my first programming language, was incredible for just that, but it also meant that my first projects were crude snippet collections that only accidentally aligned in a way that seemed to be working.

The engineers I mentor today are past that point, but still sometimes find themselves taking too little care to understand the problem first. Applying test-driven-development in this situation means you need to take a break and lay out your assumptions first. Apart from helping us both stay aligned, it also helps moving their practices away from hackery towards a more structured practice.
